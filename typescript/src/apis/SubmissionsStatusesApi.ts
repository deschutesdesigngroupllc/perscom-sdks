/* tslint:disable */
/* eslint-disable */
/**
 * PERSCOM Personnel Management System API
 * The PERSCOM API describes how to interact and manipulate your PERSCOM data available at https://perscom.io. The API provides a powerful interface to allow for third-party collaboration and integration with your PERSCOM Dashboard.
 *
 * The version of the OpenAPI document: v2
 * Contact: support@deschutesdesigngroup.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Status,
  VersionAnnouncementsAnnouncementGet404Response,
  VersionAnnouncementsBatchDeleteRequest,
  VersionAnnouncementsPost422Response,
  VersionCategoriesCategoryAwardsAttachPost200Response,
  VersionCategoriesCategoryAwardsAttachPostRequest,
  VersionCategoriesCategoryAwardsAwardPivotPatch200Response,
  VersionCategoriesCategoryAwardsAwardPivotPatchRequest,
  VersionCategoriesCategoryAwardsDetachDelete200Response,
  VersionCategoriesCategoryAwardsSyncPatch200Response,
  VersionCategoriesCategoryAwardsTogglePatch200Response,
  VersionMeGet401Response,
  VersionMeGet402Response,
  VersionMeGet403Response,
  VersionMeGet429Response,
  VersionMeGet503Response,
  VersionStatusesBatchPatchRequest,
  VersionStatusesBatchPost200Response,
  VersionStatusesBatchPostRequest,
  VersionStatusesGet200Response,
  VersionStatusesPost201Response,
} from '../models/index';
import {
    StatusFromJSON,
    StatusToJSON,
    VersionAnnouncementsAnnouncementGet404ResponseFromJSON,
    VersionAnnouncementsAnnouncementGet404ResponseToJSON,
    VersionAnnouncementsBatchDeleteRequestFromJSON,
    VersionAnnouncementsBatchDeleteRequestToJSON,
    VersionAnnouncementsPost422ResponseFromJSON,
    VersionAnnouncementsPost422ResponseToJSON,
    VersionCategoriesCategoryAwardsAttachPost200ResponseFromJSON,
    VersionCategoriesCategoryAwardsAttachPost200ResponseToJSON,
    VersionCategoriesCategoryAwardsAttachPostRequestFromJSON,
    VersionCategoriesCategoryAwardsAttachPostRequestToJSON,
    VersionCategoriesCategoryAwardsAwardPivotPatch200ResponseFromJSON,
    VersionCategoriesCategoryAwardsAwardPivotPatch200ResponseToJSON,
    VersionCategoriesCategoryAwardsAwardPivotPatchRequestFromJSON,
    VersionCategoriesCategoryAwardsAwardPivotPatchRequestToJSON,
    VersionCategoriesCategoryAwardsDetachDelete200ResponseFromJSON,
    VersionCategoriesCategoryAwardsDetachDelete200ResponseToJSON,
    VersionCategoriesCategoryAwardsSyncPatch200ResponseFromJSON,
    VersionCategoriesCategoryAwardsSyncPatch200ResponseToJSON,
    VersionCategoriesCategoryAwardsTogglePatch200ResponseFromJSON,
    VersionCategoriesCategoryAwardsTogglePatch200ResponseToJSON,
    VersionMeGet401ResponseFromJSON,
    VersionMeGet401ResponseToJSON,
    VersionMeGet402ResponseFromJSON,
    VersionMeGet402ResponseToJSON,
    VersionMeGet403ResponseFromJSON,
    VersionMeGet403ResponseToJSON,
    VersionMeGet429ResponseFromJSON,
    VersionMeGet429ResponseToJSON,
    VersionMeGet503ResponseFromJSON,
    VersionMeGet503ResponseToJSON,
    VersionStatusesBatchPatchRequestFromJSON,
    VersionStatusesBatchPatchRequestToJSON,
    VersionStatusesBatchPost200ResponseFromJSON,
    VersionStatusesBatchPost200ResponseToJSON,
    VersionStatusesBatchPostRequestFromJSON,
    VersionStatusesBatchPostRequestToJSON,
    VersionStatusesGet200ResponseFromJSON,
    VersionStatusesGet200ResponseToJSON,
    VersionStatusesPost201ResponseFromJSON,
    VersionStatusesPost201ResponseToJSON,
} from '../models/index';

export interface VersionSubmissionsSubmissionStatusesAttachPostRequest {
    version: VersionSubmissionsSubmissionStatusesAttachPostVersionEnum;
    submission: number;
    include?: VersionSubmissionsSubmissionStatusesAttachPostIncludeEnum;
    versionCategoriesCategoryAwardsAttachPostRequest?: VersionCategoriesCategoryAwardsAttachPostRequest;
}

export interface VersionSubmissionsSubmissionStatusesBatchDeleteRequest {
    version: VersionSubmissionsSubmissionStatusesBatchDeleteVersionEnum;
    submission: number;
    include?: VersionSubmissionsSubmissionStatusesBatchDeleteIncludeEnum;
    versionAnnouncementsBatchDeleteRequest?: VersionAnnouncementsBatchDeleteRequest;
}

export interface VersionSubmissionsSubmissionStatusesBatchPatchRequest {
    version: VersionSubmissionsSubmissionStatusesBatchPatchVersionEnum;
    submission: number;
    include?: VersionSubmissionsSubmissionStatusesBatchPatchIncludeEnum;
    versionStatusesBatchPatchRequest?: VersionStatusesBatchPatchRequest;
}

export interface VersionSubmissionsSubmissionStatusesBatchPostRequest {
    version: VersionSubmissionsSubmissionStatusesBatchPostVersionEnum;
    submission: number;
    include?: VersionSubmissionsSubmissionStatusesBatchPostIncludeEnum;
    versionStatusesBatchPostRequest?: VersionStatusesBatchPostRequest;
}

export interface VersionSubmissionsSubmissionStatusesDetachDeleteRequest {
    version: VersionSubmissionsSubmissionStatusesDetachDeleteVersionEnum;
    submission: number;
    include?: VersionSubmissionsSubmissionStatusesDetachDeleteIncludeEnum;
    versionCategoriesCategoryAwardsAttachPostRequest?: VersionCategoriesCategoryAwardsAttachPostRequest;
}

export interface VersionSubmissionsSubmissionStatusesGetRequest {
    version: VersionSubmissionsSubmissionStatusesGetVersionEnum;
    submission: number;
    include?: VersionSubmissionsSubmissionStatusesGetIncludeEnum;
}

export interface VersionSubmissionsSubmissionStatusesPostRequest {
    version: VersionSubmissionsSubmissionStatusesPostVersionEnum;
    submission: number;
    include?: VersionSubmissionsSubmissionStatusesPostIncludeEnum;
    status?: Status;
}

export interface VersionSubmissionsSubmissionStatusesStatusDeleteRequest {
    version: VersionSubmissionsSubmissionStatusesStatusDeleteVersionEnum;
    submission: number;
    status: number;
    include?: VersionSubmissionsSubmissionStatusesStatusDeleteIncludeEnum;
}

export interface VersionSubmissionsSubmissionStatusesStatusGetRequest {
    version: VersionSubmissionsSubmissionStatusesStatusGetVersionEnum;
    submission: number;
    status: number;
    include?: VersionSubmissionsSubmissionStatusesStatusGetIncludeEnum;
}

export interface VersionSubmissionsSubmissionStatusesStatusPatchRequest {
    version: VersionSubmissionsSubmissionStatusesStatusPatchVersionEnum;
    submission: number;
    status: number;
    include?: VersionSubmissionsSubmissionStatusesStatusPatchIncludeEnum;
    status2?: Status;
}

export interface VersionSubmissionsSubmissionStatusesStatusPivotPatchRequest {
    version: VersionSubmissionsSubmissionStatusesStatusPivotPatchVersionEnum;
    submission: number;
    status: number;
    include?: VersionSubmissionsSubmissionStatusesStatusPivotPatchIncludeEnum;
    versionCategoriesCategoryAwardsAwardPivotPatchRequest?: VersionCategoriesCategoryAwardsAwardPivotPatchRequest;
}

export interface VersionSubmissionsSubmissionStatusesSyncPatchRequest {
    version: VersionSubmissionsSubmissionStatusesSyncPatchVersionEnum;
    submission: number;
    include?: VersionSubmissionsSubmissionStatusesSyncPatchIncludeEnum;
    versionCategoriesCategoryAwardsAttachPostRequest?: VersionCategoriesCategoryAwardsAttachPostRequest;
}

export interface VersionSubmissionsSubmissionStatusesTogglePatchRequest {
    version: VersionSubmissionsSubmissionStatusesTogglePatchVersionEnum;
    submission: number;
    include?: VersionSubmissionsSubmissionStatusesTogglePatchIncludeEnum;
    versionCategoriesCategoryAwardsAttachPostRequest?: VersionCategoriesCategoryAwardsAttachPostRequest;
}

/**
 * 
 */
export class SubmissionsStatusesApi extends runtime.BaseAPI {

    /**
     * Attach statuses
     */
    async versionSubmissionsSubmissionStatusesAttachPostRaw(requestParameters: VersionSubmissionsSubmissionStatusesAttachPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionCategoriesCategoryAwardsAttachPost200Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionSubmissionsSubmissionStatusesAttachPost().'
            );
        }

        if (requestParameters['submission'] == null) {
            throw new runtime.RequiredError(
                'submission',
                'Required parameter "submission" was null or undefined when calling versionSubmissionsSubmissionStatusesAttachPost().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['include'] != null) {
            queryParameters['include'] = requestParameters['include'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/submissions/{submission}/statuses/attach`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"submission"}}`, encodeURIComponent(String(requestParameters['submission']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: VersionCategoriesCategoryAwardsAttachPostRequestToJSON(requestParameters['versionCategoriesCategoryAwardsAttachPostRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionCategoriesCategoryAwardsAttachPost200ResponseFromJSON(jsonValue));
    }

    /**
     * Attach statuses
     */
    async versionSubmissionsSubmissionStatusesAttachPost(requestParameters: VersionSubmissionsSubmissionStatusesAttachPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionCategoriesCategoryAwardsAttachPost200Response> {
        const response = await this.versionSubmissionsSubmissionStatusesAttachPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a batch of statuses
     */
    async versionSubmissionsSubmissionStatusesBatchDeleteRaw(requestParameters: VersionSubmissionsSubmissionStatusesBatchDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionStatusesBatchPost200Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionSubmissionsSubmissionStatusesBatchDelete().'
            );
        }

        if (requestParameters['submission'] == null) {
            throw new runtime.RequiredError(
                'submission',
                'Required parameter "submission" was null or undefined when calling versionSubmissionsSubmissionStatusesBatchDelete().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['include'] != null) {
            queryParameters['include'] = requestParameters['include'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/submissions/{submission}/statuses/batch`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"submission"}}`, encodeURIComponent(String(requestParameters['submission']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: VersionAnnouncementsBatchDeleteRequestToJSON(requestParameters['versionAnnouncementsBatchDeleteRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionStatusesBatchPost200ResponseFromJSON(jsonValue));
    }

    /**
     * Delete a batch of statuses
     */
    async versionSubmissionsSubmissionStatusesBatchDelete(requestParameters: VersionSubmissionsSubmissionStatusesBatchDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionStatusesBatchPost200Response> {
        const response = await this.versionSubmissionsSubmissionStatusesBatchDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a batch of statuses
     */
    async versionSubmissionsSubmissionStatusesBatchPatchRaw(requestParameters: VersionSubmissionsSubmissionStatusesBatchPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionStatusesBatchPost200Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionSubmissionsSubmissionStatusesBatchPatch().'
            );
        }

        if (requestParameters['submission'] == null) {
            throw new runtime.RequiredError(
                'submission',
                'Required parameter "submission" was null or undefined when calling versionSubmissionsSubmissionStatusesBatchPatch().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['include'] != null) {
            queryParameters['include'] = requestParameters['include'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/submissions/{submission}/statuses/batch`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"submission"}}`, encodeURIComponent(String(requestParameters['submission']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: VersionStatusesBatchPatchRequestToJSON(requestParameters['versionStatusesBatchPatchRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionStatusesBatchPost200ResponseFromJSON(jsonValue));
    }

    /**
     * Update a batch of statuses
     */
    async versionSubmissionsSubmissionStatusesBatchPatch(requestParameters: VersionSubmissionsSubmissionStatusesBatchPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionStatusesBatchPost200Response> {
        const response = await this.versionSubmissionsSubmissionStatusesBatchPatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a batch of statuses
     */
    async versionSubmissionsSubmissionStatusesBatchPostRaw(requestParameters: VersionSubmissionsSubmissionStatusesBatchPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionStatusesBatchPost200Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionSubmissionsSubmissionStatusesBatchPost().'
            );
        }

        if (requestParameters['submission'] == null) {
            throw new runtime.RequiredError(
                'submission',
                'Required parameter "submission" was null or undefined when calling versionSubmissionsSubmissionStatusesBatchPost().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['include'] != null) {
            queryParameters['include'] = requestParameters['include'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/submissions/{submission}/statuses/batch`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"submission"}}`, encodeURIComponent(String(requestParameters['submission']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: VersionStatusesBatchPostRequestToJSON(requestParameters['versionStatusesBatchPostRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionStatusesBatchPost200ResponseFromJSON(jsonValue));
    }

    /**
     * Create a batch of statuses
     */
    async versionSubmissionsSubmissionStatusesBatchPost(requestParameters: VersionSubmissionsSubmissionStatusesBatchPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionStatusesBatchPost200Response> {
        const response = await this.versionSubmissionsSubmissionStatusesBatchPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Detach statuses
     */
    async versionSubmissionsSubmissionStatusesDetachDeleteRaw(requestParameters: VersionSubmissionsSubmissionStatusesDetachDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionCategoriesCategoryAwardsDetachDelete200Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionSubmissionsSubmissionStatusesDetachDelete().'
            );
        }

        if (requestParameters['submission'] == null) {
            throw new runtime.RequiredError(
                'submission',
                'Required parameter "submission" was null or undefined when calling versionSubmissionsSubmissionStatusesDetachDelete().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['include'] != null) {
            queryParameters['include'] = requestParameters['include'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/submissions/{submission}/statuses/detach`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"submission"}}`, encodeURIComponent(String(requestParameters['submission']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: VersionCategoriesCategoryAwardsAttachPostRequestToJSON(requestParameters['versionCategoriesCategoryAwardsAttachPostRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionCategoriesCategoryAwardsDetachDelete200ResponseFromJSON(jsonValue));
    }

    /**
     * Detach statuses
     */
    async versionSubmissionsSubmissionStatusesDetachDelete(requestParameters: VersionSubmissionsSubmissionStatusesDetachDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionCategoriesCategoryAwardsDetachDelete200Response> {
        const response = await this.versionSubmissionsSubmissionStatusesDetachDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of statuses
     */
    async versionSubmissionsSubmissionStatusesGetRaw(requestParameters: VersionSubmissionsSubmissionStatusesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionStatusesGet200Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionSubmissionsSubmissionStatusesGet().'
            );
        }

        if (requestParameters['submission'] == null) {
            throw new runtime.RequiredError(
                'submission',
                'Required parameter "submission" was null or undefined when calling versionSubmissionsSubmissionStatusesGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['include'] != null) {
            queryParameters['include'] = requestParameters['include'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/submissions/{submission}/statuses`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"submission"}}`, encodeURIComponent(String(requestParameters['submission']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionStatusesGet200ResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of statuses
     */
    async versionSubmissionsSubmissionStatusesGet(requestParameters: VersionSubmissionsSubmissionStatusesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionStatusesGet200Response> {
        const response = await this.versionSubmissionsSubmissionStatusesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create status
     */
    async versionSubmissionsSubmissionStatusesPostRaw(requestParameters: VersionSubmissionsSubmissionStatusesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionStatusesPost201Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionSubmissionsSubmissionStatusesPost().'
            );
        }

        if (requestParameters['submission'] == null) {
            throw new runtime.RequiredError(
                'submission',
                'Required parameter "submission" was null or undefined when calling versionSubmissionsSubmissionStatusesPost().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['include'] != null) {
            queryParameters['include'] = requestParameters['include'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/submissions/{submission}/statuses`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"submission"}}`, encodeURIComponent(String(requestParameters['submission']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StatusToJSON(requestParameters['status']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionStatusesPost201ResponseFromJSON(jsonValue));
    }

    /**
     * Create status
     */
    async versionSubmissionsSubmissionStatusesPost(requestParameters: VersionSubmissionsSubmissionStatusesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionStatusesPost201Response> {
        const response = await this.versionSubmissionsSubmissionStatusesPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete status
     */
    async versionSubmissionsSubmissionStatusesStatusDeleteRaw(requestParameters: VersionSubmissionsSubmissionStatusesStatusDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionStatusesPost201Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionSubmissionsSubmissionStatusesStatusDelete().'
            );
        }

        if (requestParameters['submission'] == null) {
            throw new runtime.RequiredError(
                'submission',
                'Required parameter "submission" was null or undefined when calling versionSubmissionsSubmissionStatusesStatusDelete().'
            );
        }

        if (requestParameters['status'] == null) {
            throw new runtime.RequiredError(
                'status',
                'Required parameter "status" was null or undefined when calling versionSubmissionsSubmissionStatusesStatusDelete().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['include'] != null) {
            queryParameters['include'] = requestParameters['include'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/submissions/{submission}/statuses/{status}`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"submission"}}`, encodeURIComponent(String(requestParameters['submission']))).replace(`{${"status"}}`, encodeURIComponent(String(requestParameters['status']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionStatusesPost201ResponseFromJSON(jsonValue));
    }

    /**
     * Delete status
     */
    async versionSubmissionsSubmissionStatusesStatusDelete(requestParameters: VersionSubmissionsSubmissionStatusesStatusDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionStatusesPost201Response> {
        const response = await this.versionSubmissionsSubmissionStatusesStatusDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get status
     */
    async versionSubmissionsSubmissionStatusesStatusGetRaw(requestParameters: VersionSubmissionsSubmissionStatusesStatusGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionStatusesPost201Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionSubmissionsSubmissionStatusesStatusGet().'
            );
        }

        if (requestParameters['submission'] == null) {
            throw new runtime.RequiredError(
                'submission',
                'Required parameter "submission" was null or undefined when calling versionSubmissionsSubmissionStatusesStatusGet().'
            );
        }

        if (requestParameters['status'] == null) {
            throw new runtime.RequiredError(
                'status',
                'Required parameter "status" was null or undefined when calling versionSubmissionsSubmissionStatusesStatusGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['include'] != null) {
            queryParameters['include'] = requestParameters['include'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/submissions/{submission}/statuses/{status}`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"submission"}}`, encodeURIComponent(String(requestParameters['submission']))).replace(`{${"status"}}`, encodeURIComponent(String(requestParameters['status']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionStatusesPost201ResponseFromJSON(jsonValue));
    }

    /**
     * Get status
     */
    async versionSubmissionsSubmissionStatusesStatusGet(requestParameters: VersionSubmissionsSubmissionStatusesStatusGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionStatusesPost201Response> {
        const response = await this.versionSubmissionsSubmissionStatusesStatusGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update status
     */
    async versionSubmissionsSubmissionStatusesStatusPatchRaw(requestParameters: VersionSubmissionsSubmissionStatusesStatusPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionStatusesPost201Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionSubmissionsSubmissionStatusesStatusPatch().'
            );
        }

        if (requestParameters['submission'] == null) {
            throw new runtime.RequiredError(
                'submission',
                'Required parameter "submission" was null or undefined when calling versionSubmissionsSubmissionStatusesStatusPatch().'
            );
        }

        if (requestParameters['status'] == null) {
            throw new runtime.RequiredError(
                'status',
                'Required parameter "status" was null or undefined when calling versionSubmissionsSubmissionStatusesStatusPatch().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['include'] != null) {
            queryParameters['include'] = requestParameters['include'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/submissions/{submission}/statuses/{status}`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"submission"}}`, encodeURIComponent(String(requestParameters['submission']))).replace(`{${"status"}}`, encodeURIComponent(String(requestParameters['status']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: StatusToJSON(requestParameters['status2']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionStatusesPost201ResponseFromJSON(jsonValue));
    }

    /**
     * Update status
     */
    async versionSubmissionsSubmissionStatusesStatusPatch(requestParameters: VersionSubmissionsSubmissionStatusesStatusPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionStatusesPost201Response> {
        const response = await this.versionSubmissionsSubmissionStatusesStatusPatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update pivot
     */
    async versionSubmissionsSubmissionStatusesStatusPivotPatchRaw(requestParameters: VersionSubmissionsSubmissionStatusesStatusPivotPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionCategoriesCategoryAwardsAwardPivotPatch200Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionSubmissionsSubmissionStatusesStatusPivotPatch().'
            );
        }

        if (requestParameters['submission'] == null) {
            throw new runtime.RequiredError(
                'submission',
                'Required parameter "submission" was null or undefined when calling versionSubmissionsSubmissionStatusesStatusPivotPatch().'
            );
        }

        if (requestParameters['status'] == null) {
            throw new runtime.RequiredError(
                'status',
                'Required parameter "status" was null or undefined when calling versionSubmissionsSubmissionStatusesStatusPivotPatch().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['include'] != null) {
            queryParameters['include'] = requestParameters['include'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/submissions/{submission}/statuses/{status}/pivot`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"submission"}}`, encodeURIComponent(String(requestParameters['submission']))).replace(`{${"status"}}`, encodeURIComponent(String(requestParameters['status']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: VersionCategoriesCategoryAwardsAwardPivotPatchRequestToJSON(requestParameters['versionCategoriesCategoryAwardsAwardPivotPatchRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionCategoriesCategoryAwardsAwardPivotPatch200ResponseFromJSON(jsonValue));
    }

    /**
     * Update pivot
     */
    async versionSubmissionsSubmissionStatusesStatusPivotPatch(requestParameters: VersionSubmissionsSubmissionStatusesStatusPivotPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionCategoriesCategoryAwardsAwardPivotPatch200Response> {
        const response = await this.versionSubmissionsSubmissionStatusesStatusPivotPatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sync statuses
     */
    async versionSubmissionsSubmissionStatusesSyncPatchRaw(requestParameters: VersionSubmissionsSubmissionStatusesSyncPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionCategoriesCategoryAwardsSyncPatch200Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionSubmissionsSubmissionStatusesSyncPatch().'
            );
        }

        if (requestParameters['submission'] == null) {
            throw new runtime.RequiredError(
                'submission',
                'Required parameter "submission" was null or undefined when calling versionSubmissionsSubmissionStatusesSyncPatch().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['include'] != null) {
            queryParameters['include'] = requestParameters['include'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/submissions/{submission}/statuses/sync`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"submission"}}`, encodeURIComponent(String(requestParameters['submission']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: VersionCategoriesCategoryAwardsAttachPostRequestToJSON(requestParameters['versionCategoriesCategoryAwardsAttachPostRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionCategoriesCategoryAwardsSyncPatch200ResponseFromJSON(jsonValue));
    }

    /**
     * Sync statuses
     */
    async versionSubmissionsSubmissionStatusesSyncPatch(requestParameters: VersionSubmissionsSubmissionStatusesSyncPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionCategoriesCategoryAwardsSyncPatch200Response> {
        const response = await this.versionSubmissionsSubmissionStatusesSyncPatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Toggle statuses
     */
    async versionSubmissionsSubmissionStatusesTogglePatchRaw(requestParameters: VersionSubmissionsSubmissionStatusesTogglePatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionCategoriesCategoryAwardsTogglePatch200Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionSubmissionsSubmissionStatusesTogglePatch().'
            );
        }

        if (requestParameters['submission'] == null) {
            throw new runtime.RequiredError(
                'submission',
                'Required parameter "submission" was null or undefined when calling versionSubmissionsSubmissionStatusesTogglePatch().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['include'] != null) {
            queryParameters['include'] = requestParameters['include'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/submissions/{submission}/statuses/toggle`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"submission"}}`, encodeURIComponent(String(requestParameters['submission']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: VersionCategoriesCategoryAwardsAttachPostRequestToJSON(requestParameters['versionCategoriesCategoryAwardsAttachPostRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionCategoriesCategoryAwardsTogglePatch200ResponseFromJSON(jsonValue));
    }

    /**
     * Toggle statuses
     */
    async versionSubmissionsSubmissionStatusesTogglePatch(requestParameters: VersionSubmissionsSubmissionStatusesTogglePatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionCategoriesCategoryAwardsTogglePatch200Response> {
        const response = await this.versionSubmissionsSubmissionStatusesTogglePatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesAttachPostVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionSubmissionsSubmissionStatusesAttachPostVersionEnum = typeof VersionSubmissionsSubmissionStatusesAttachPostVersionEnum[keyof typeof VersionSubmissionsSubmissionStatusesAttachPostVersionEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesAttachPostIncludeEnum = {
    Record: 'record'
} as const;
export type VersionSubmissionsSubmissionStatusesAttachPostIncludeEnum = typeof VersionSubmissionsSubmissionStatusesAttachPostIncludeEnum[keyof typeof VersionSubmissionsSubmissionStatusesAttachPostIncludeEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesBatchDeleteVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionSubmissionsSubmissionStatusesBatchDeleteVersionEnum = typeof VersionSubmissionsSubmissionStatusesBatchDeleteVersionEnum[keyof typeof VersionSubmissionsSubmissionStatusesBatchDeleteVersionEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesBatchDeleteIncludeEnum = {
    Record: 'record'
} as const;
export type VersionSubmissionsSubmissionStatusesBatchDeleteIncludeEnum = typeof VersionSubmissionsSubmissionStatusesBatchDeleteIncludeEnum[keyof typeof VersionSubmissionsSubmissionStatusesBatchDeleteIncludeEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesBatchPatchVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionSubmissionsSubmissionStatusesBatchPatchVersionEnum = typeof VersionSubmissionsSubmissionStatusesBatchPatchVersionEnum[keyof typeof VersionSubmissionsSubmissionStatusesBatchPatchVersionEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesBatchPatchIncludeEnum = {
    Record: 'record'
} as const;
export type VersionSubmissionsSubmissionStatusesBatchPatchIncludeEnum = typeof VersionSubmissionsSubmissionStatusesBatchPatchIncludeEnum[keyof typeof VersionSubmissionsSubmissionStatusesBatchPatchIncludeEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesBatchPostVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionSubmissionsSubmissionStatusesBatchPostVersionEnum = typeof VersionSubmissionsSubmissionStatusesBatchPostVersionEnum[keyof typeof VersionSubmissionsSubmissionStatusesBatchPostVersionEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesBatchPostIncludeEnum = {
    Record: 'record'
} as const;
export type VersionSubmissionsSubmissionStatusesBatchPostIncludeEnum = typeof VersionSubmissionsSubmissionStatusesBatchPostIncludeEnum[keyof typeof VersionSubmissionsSubmissionStatusesBatchPostIncludeEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesDetachDeleteVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionSubmissionsSubmissionStatusesDetachDeleteVersionEnum = typeof VersionSubmissionsSubmissionStatusesDetachDeleteVersionEnum[keyof typeof VersionSubmissionsSubmissionStatusesDetachDeleteVersionEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesDetachDeleteIncludeEnum = {
    Record: 'record'
} as const;
export type VersionSubmissionsSubmissionStatusesDetachDeleteIncludeEnum = typeof VersionSubmissionsSubmissionStatusesDetachDeleteIncludeEnum[keyof typeof VersionSubmissionsSubmissionStatusesDetachDeleteIncludeEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesGetVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionSubmissionsSubmissionStatusesGetVersionEnum = typeof VersionSubmissionsSubmissionStatusesGetVersionEnum[keyof typeof VersionSubmissionsSubmissionStatusesGetVersionEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesGetIncludeEnum = {
    Record: 'record'
} as const;
export type VersionSubmissionsSubmissionStatusesGetIncludeEnum = typeof VersionSubmissionsSubmissionStatusesGetIncludeEnum[keyof typeof VersionSubmissionsSubmissionStatusesGetIncludeEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesPostVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionSubmissionsSubmissionStatusesPostVersionEnum = typeof VersionSubmissionsSubmissionStatusesPostVersionEnum[keyof typeof VersionSubmissionsSubmissionStatusesPostVersionEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesPostIncludeEnum = {
    Record: 'record'
} as const;
export type VersionSubmissionsSubmissionStatusesPostIncludeEnum = typeof VersionSubmissionsSubmissionStatusesPostIncludeEnum[keyof typeof VersionSubmissionsSubmissionStatusesPostIncludeEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesStatusDeleteVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionSubmissionsSubmissionStatusesStatusDeleteVersionEnum = typeof VersionSubmissionsSubmissionStatusesStatusDeleteVersionEnum[keyof typeof VersionSubmissionsSubmissionStatusesStatusDeleteVersionEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesStatusDeleteIncludeEnum = {
    Record: 'record'
} as const;
export type VersionSubmissionsSubmissionStatusesStatusDeleteIncludeEnum = typeof VersionSubmissionsSubmissionStatusesStatusDeleteIncludeEnum[keyof typeof VersionSubmissionsSubmissionStatusesStatusDeleteIncludeEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesStatusGetVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionSubmissionsSubmissionStatusesStatusGetVersionEnum = typeof VersionSubmissionsSubmissionStatusesStatusGetVersionEnum[keyof typeof VersionSubmissionsSubmissionStatusesStatusGetVersionEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesStatusGetIncludeEnum = {
    Record: 'record'
} as const;
export type VersionSubmissionsSubmissionStatusesStatusGetIncludeEnum = typeof VersionSubmissionsSubmissionStatusesStatusGetIncludeEnum[keyof typeof VersionSubmissionsSubmissionStatusesStatusGetIncludeEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesStatusPatchVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionSubmissionsSubmissionStatusesStatusPatchVersionEnum = typeof VersionSubmissionsSubmissionStatusesStatusPatchVersionEnum[keyof typeof VersionSubmissionsSubmissionStatusesStatusPatchVersionEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesStatusPatchIncludeEnum = {
    Record: 'record'
} as const;
export type VersionSubmissionsSubmissionStatusesStatusPatchIncludeEnum = typeof VersionSubmissionsSubmissionStatusesStatusPatchIncludeEnum[keyof typeof VersionSubmissionsSubmissionStatusesStatusPatchIncludeEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesStatusPivotPatchVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionSubmissionsSubmissionStatusesStatusPivotPatchVersionEnum = typeof VersionSubmissionsSubmissionStatusesStatusPivotPatchVersionEnum[keyof typeof VersionSubmissionsSubmissionStatusesStatusPivotPatchVersionEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesStatusPivotPatchIncludeEnum = {
    Record: 'record'
} as const;
export type VersionSubmissionsSubmissionStatusesStatusPivotPatchIncludeEnum = typeof VersionSubmissionsSubmissionStatusesStatusPivotPatchIncludeEnum[keyof typeof VersionSubmissionsSubmissionStatusesStatusPivotPatchIncludeEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesSyncPatchVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionSubmissionsSubmissionStatusesSyncPatchVersionEnum = typeof VersionSubmissionsSubmissionStatusesSyncPatchVersionEnum[keyof typeof VersionSubmissionsSubmissionStatusesSyncPatchVersionEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesSyncPatchIncludeEnum = {
    Record: 'record'
} as const;
export type VersionSubmissionsSubmissionStatusesSyncPatchIncludeEnum = typeof VersionSubmissionsSubmissionStatusesSyncPatchIncludeEnum[keyof typeof VersionSubmissionsSubmissionStatusesSyncPatchIncludeEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesTogglePatchVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionSubmissionsSubmissionStatusesTogglePatchVersionEnum = typeof VersionSubmissionsSubmissionStatusesTogglePatchVersionEnum[keyof typeof VersionSubmissionsSubmissionStatusesTogglePatchVersionEnum];
/**
 * @export
 */
export const VersionSubmissionsSubmissionStatusesTogglePatchIncludeEnum = {
    Record: 'record'
} as const;
export type VersionSubmissionsSubmissionStatusesTogglePatchIncludeEnum = typeof VersionSubmissionsSubmissionStatusesTogglePatchIncludeEnum[keyof typeof VersionSubmissionsSubmissionStatusesTogglePatchIncludeEnum];
