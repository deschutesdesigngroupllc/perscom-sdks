/* tslint:disable */
/* eslint-disable */
/**
 * PERSCOM Personnel Management System API
 * The PERSCOM API describes how to interact and manipulate your PERSCOM data available at https://perscom.io. The API provides a powerful interface to allow for third-party collaboration and integration with your PERSCOM Dashboard.
 *
 * The version of the OpenAPI document: v2
 * Contact: support@deschutesdesigngroup.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Field,
  VersionAnnouncementsAnnouncementGet404Response,
  VersionAnnouncementsBatchDeleteRequest,
  VersionAnnouncementsPost422Response,
  VersionCategoriesCategoryAwardsAttachPost200Response,
  VersionCategoriesCategoryAwardsAttachPostRequest,
  VersionCategoriesCategoryAwardsAwardPivotPatch200Response,
  VersionCategoriesCategoryAwardsAwardPivotPatchRequest,
  VersionCategoriesCategoryAwardsDetachDelete200Response,
  VersionCategoriesCategoryAwardsSyncPatch200Response,
  VersionCategoriesCategoryAwardsTogglePatch200Response,
  VersionFormsFormFieldsBatchPatchRequest,
  VersionFormsFormFieldsBatchPost200Response,
  VersionFormsFormFieldsBatchPostRequest,
  VersionFormsFormFieldsGet200Response,
  VersionFormsFormFieldsPost201Response,
  VersionMeGet401Response,
  VersionMeGet402Response,
  VersionMeGet403Response,
  VersionMeGet429Response,
  VersionMeGet503Response,
} from '../models/index';
import {
    FieldFromJSON,
    FieldToJSON,
    VersionAnnouncementsAnnouncementGet404ResponseFromJSON,
    VersionAnnouncementsAnnouncementGet404ResponseToJSON,
    VersionAnnouncementsBatchDeleteRequestFromJSON,
    VersionAnnouncementsBatchDeleteRequestToJSON,
    VersionAnnouncementsPost422ResponseFromJSON,
    VersionAnnouncementsPost422ResponseToJSON,
    VersionCategoriesCategoryAwardsAttachPost200ResponseFromJSON,
    VersionCategoriesCategoryAwardsAttachPost200ResponseToJSON,
    VersionCategoriesCategoryAwardsAttachPostRequestFromJSON,
    VersionCategoriesCategoryAwardsAttachPostRequestToJSON,
    VersionCategoriesCategoryAwardsAwardPivotPatch200ResponseFromJSON,
    VersionCategoriesCategoryAwardsAwardPivotPatch200ResponseToJSON,
    VersionCategoriesCategoryAwardsAwardPivotPatchRequestFromJSON,
    VersionCategoriesCategoryAwardsAwardPivotPatchRequestToJSON,
    VersionCategoriesCategoryAwardsDetachDelete200ResponseFromJSON,
    VersionCategoriesCategoryAwardsDetachDelete200ResponseToJSON,
    VersionCategoriesCategoryAwardsSyncPatch200ResponseFromJSON,
    VersionCategoriesCategoryAwardsSyncPatch200ResponseToJSON,
    VersionCategoriesCategoryAwardsTogglePatch200ResponseFromJSON,
    VersionCategoriesCategoryAwardsTogglePatch200ResponseToJSON,
    VersionFormsFormFieldsBatchPatchRequestFromJSON,
    VersionFormsFormFieldsBatchPatchRequestToJSON,
    VersionFormsFormFieldsBatchPost200ResponseFromJSON,
    VersionFormsFormFieldsBatchPost200ResponseToJSON,
    VersionFormsFormFieldsBatchPostRequestFromJSON,
    VersionFormsFormFieldsBatchPostRequestToJSON,
    VersionFormsFormFieldsGet200ResponseFromJSON,
    VersionFormsFormFieldsGet200ResponseToJSON,
    VersionFormsFormFieldsPost201ResponseFromJSON,
    VersionFormsFormFieldsPost201ResponseToJSON,
    VersionMeGet401ResponseFromJSON,
    VersionMeGet401ResponseToJSON,
    VersionMeGet402ResponseFromJSON,
    VersionMeGet402ResponseToJSON,
    VersionMeGet403ResponseFromJSON,
    VersionMeGet403ResponseToJSON,
    VersionMeGet429ResponseFromJSON,
    VersionMeGet429ResponseToJSON,
    VersionMeGet503ResponseFromJSON,
    VersionMeGet503ResponseToJSON,
} from '../models/index';

export interface VersionUsersUserFieldsAttachPostRequest {
    version: VersionUsersUserFieldsAttachPostVersionEnum;
    user: number;
    versionCategoriesCategoryAwardsAttachPostRequest?: VersionCategoriesCategoryAwardsAttachPostRequest;
}

export interface VersionUsersUserFieldsBatchDeleteRequest {
    version: VersionUsersUserFieldsBatchDeleteVersionEnum;
    user: number;
    versionAnnouncementsBatchDeleteRequest?: VersionAnnouncementsBatchDeleteRequest;
}

export interface VersionUsersUserFieldsBatchPatchRequest {
    version: VersionUsersUserFieldsBatchPatchVersionEnum;
    user: number;
    versionFormsFormFieldsBatchPatchRequest?: VersionFormsFormFieldsBatchPatchRequest;
}

export interface VersionUsersUserFieldsBatchPostRequest {
    version: VersionUsersUserFieldsBatchPostVersionEnum;
    user: number;
    versionFormsFormFieldsBatchPostRequest?: VersionFormsFormFieldsBatchPostRequest;
}

export interface VersionUsersUserFieldsDetachDeleteRequest {
    version: VersionUsersUserFieldsDetachDeleteVersionEnum;
    user: number;
    versionCategoriesCategoryAwardsAttachPostRequest?: VersionCategoriesCategoryAwardsAttachPostRequest;
}

export interface VersionUsersUserFieldsFieldDeleteRequest {
    version: VersionUsersUserFieldsFieldDeleteVersionEnum;
    user: number;
    field: number;
}

export interface VersionUsersUserFieldsFieldGetRequest {
    version: VersionUsersUserFieldsFieldGetVersionEnum;
    user: number;
    field: number;
}

export interface VersionUsersUserFieldsFieldPatchRequest {
    version: VersionUsersUserFieldsFieldPatchVersionEnum;
    user: number;
    field: number;
    field2?: Field;
}

export interface VersionUsersUserFieldsFieldPivotPatchRequest {
    version: VersionUsersUserFieldsFieldPivotPatchVersionEnum;
    user: number;
    field: number;
    versionCategoriesCategoryAwardsAwardPivotPatchRequest?: VersionCategoriesCategoryAwardsAwardPivotPatchRequest;
}

export interface VersionUsersUserFieldsGetRequest {
    version: VersionUsersUserFieldsGetVersionEnum;
    user: number;
}

export interface VersionUsersUserFieldsPostRequest {
    version: VersionUsersUserFieldsPostVersionEnum;
    user: number;
    field?: Field;
}

export interface VersionUsersUserFieldsSyncPatchRequest {
    version: VersionUsersUserFieldsSyncPatchVersionEnum;
    user: number;
    versionCategoriesCategoryAwardsAttachPostRequest?: VersionCategoriesCategoryAwardsAttachPostRequest;
}

export interface VersionUsersUserFieldsTogglePatchRequest {
    version: VersionUsersUserFieldsTogglePatchVersionEnum;
    user: number;
    versionCategoriesCategoryAwardsAttachPostRequest?: VersionCategoriesCategoryAwardsAttachPostRequest;
}

/**
 * 
 */
export class UsersFieldsApi extends runtime.BaseAPI {

    /**
     * Attach fields
     */
    async versionUsersUserFieldsAttachPostRaw(requestParameters: VersionUsersUserFieldsAttachPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionCategoriesCategoryAwardsAttachPost200Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionUsersUserFieldsAttachPost().'
            );
        }

        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling versionUsersUserFieldsAttachPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/users/{user}/fields/attach`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: VersionCategoriesCategoryAwardsAttachPostRequestToJSON(requestParameters['versionCategoriesCategoryAwardsAttachPostRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionCategoriesCategoryAwardsAttachPost200ResponseFromJSON(jsonValue));
    }

    /**
     * Attach fields
     */
    async versionUsersUserFieldsAttachPost(requestParameters: VersionUsersUserFieldsAttachPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionCategoriesCategoryAwardsAttachPost200Response> {
        const response = await this.versionUsersUserFieldsAttachPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a batch of fields
     */
    async versionUsersUserFieldsBatchDeleteRaw(requestParameters: VersionUsersUserFieldsBatchDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionFormsFormFieldsBatchPost200Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionUsersUserFieldsBatchDelete().'
            );
        }

        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling versionUsersUserFieldsBatchDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/users/{user}/fields/batch`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: VersionAnnouncementsBatchDeleteRequestToJSON(requestParameters['versionAnnouncementsBatchDeleteRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionFormsFormFieldsBatchPost200ResponseFromJSON(jsonValue));
    }

    /**
     * Delete a batch of fields
     */
    async versionUsersUserFieldsBatchDelete(requestParameters: VersionUsersUserFieldsBatchDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionFormsFormFieldsBatchPost200Response> {
        const response = await this.versionUsersUserFieldsBatchDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a batch of fields
     */
    async versionUsersUserFieldsBatchPatchRaw(requestParameters: VersionUsersUserFieldsBatchPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionFormsFormFieldsBatchPost200Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionUsersUserFieldsBatchPatch().'
            );
        }

        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling versionUsersUserFieldsBatchPatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/users/{user}/fields/batch`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: VersionFormsFormFieldsBatchPatchRequestToJSON(requestParameters['versionFormsFormFieldsBatchPatchRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionFormsFormFieldsBatchPost200ResponseFromJSON(jsonValue));
    }

    /**
     * Update a batch of fields
     */
    async versionUsersUserFieldsBatchPatch(requestParameters: VersionUsersUserFieldsBatchPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionFormsFormFieldsBatchPost200Response> {
        const response = await this.versionUsersUserFieldsBatchPatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a batch of fields
     */
    async versionUsersUserFieldsBatchPostRaw(requestParameters: VersionUsersUserFieldsBatchPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionFormsFormFieldsBatchPost200Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionUsersUserFieldsBatchPost().'
            );
        }

        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling versionUsersUserFieldsBatchPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/users/{user}/fields/batch`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: VersionFormsFormFieldsBatchPostRequestToJSON(requestParameters['versionFormsFormFieldsBatchPostRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionFormsFormFieldsBatchPost200ResponseFromJSON(jsonValue));
    }

    /**
     * Create a batch of fields
     */
    async versionUsersUserFieldsBatchPost(requestParameters: VersionUsersUserFieldsBatchPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionFormsFormFieldsBatchPost200Response> {
        const response = await this.versionUsersUserFieldsBatchPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Detach fields
     */
    async versionUsersUserFieldsDetachDeleteRaw(requestParameters: VersionUsersUserFieldsDetachDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionCategoriesCategoryAwardsDetachDelete200Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionUsersUserFieldsDetachDelete().'
            );
        }

        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling versionUsersUserFieldsDetachDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/users/{user}/fields/detach`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: VersionCategoriesCategoryAwardsAttachPostRequestToJSON(requestParameters['versionCategoriesCategoryAwardsAttachPostRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionCategoriesCategoryAwardsDetachDelete200ResponseFromJSON(jsonValue));
    }

    /**
     * Detach fields
     */
    async versionUsersUserFieldsDetachDelete(requestParameters: VersionUsersUserFieldsDetachDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionCategoriesCategoryAwardsDetachDelete200Response> {
        const response = await this.versionUsersUserFieldsDetachDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete field
     */
    async versionUsersUserFieldsFieldDeleteRaw(requestParameters: VersionUsersUserFieldsFieldDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionFormsFormFieldsPost201Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionUsersUserFieldsFieldDelete().'
            );
        }

        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling versionUsersUserFieldsFieldDelete().'
            );
        }

        if (requestParameters['field'] == null) {
            throw new runtime.RequiredError(
                'field',
                'Required parameter "field" was null or undefined when calling versionUsersUserFieldsFieldDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/users/{user}/fields/{field}`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user']))).replace(`{${"field"}}`, encodeURIComponent(String(requestParameters['field']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionFormsFormFieldsPost201ResponseFromJSON(jsonValue));
    }

    /**
     * Delete field
     */
    async versionUsersUserFieldsFieldDelete(requestParameters: VersionUsersUserFieldsFieldDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionFormsFormFieldsPost201Response> {
        const response = await this.versionUsersUserFieldsFieldDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get field
     */
    async versionUsersUserFieldsFieldGetRaw(requestParameters: VersionUsersUserFieldsFieldGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionFormsFormFieldsPost201Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionUsersUserFieldsFieldGet().'
            );
        }

        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling versionUsersUserFieldsFieldGet().'
            );
        }

        if (requestParameters['field'] == null) {
            throw new runtime.RequiredError(
                'field',
                'Required parameter "field" was null or undefined when calling versionUsersUserFieldsFieldGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/users/{user}/fields/{field}`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user']))).replace(`{${"field"}}`, encodeURIComponent(String(requestParameters['field']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionFormsFormFieldsPost201ResponseFromJSON(jsonValue));
    }

    /**
     * Get field
     */
    async versionUsersUserFieldsFieldGet(requestParameters: VersionUsersUserFieldsFieldGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionFormsFormFieldsPost201Response> {
        const response = await this.versionUsersUserFieldsFieldGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update field
     */
    async versionUsersUserFieldsFieldPatchRaw(requestParameters: VersionUsersUserFieldsFieldPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionFormsFormFieldsPost201Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionUsersUserFieldsFieldPatch().'
            );
        }

        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling versionUsersUserFieldsFieldPatch().'
            );
        }

        if (requestParameters['field'] == null) {
            throw new runtime.RequiredError(
                'field',
                'Required parameter "field" was null or undefined when calling versionUsersUserFieldsFieldPatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/users/{user}/fields/{field}`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user']))).replace(`{${"field"}}`, encodeURIComponent(String(requestParameters['field']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: FieldToJSON(requestParameters['field2']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionFormsFormFieldsPost201ResponseFromJSON(jsonValue));
    }

    /**
     * Update field
     */
    async versionUsersUserFieldsFieldPatch(requestParameters: VersionUsersUserFieldsFieldPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionFormsFormFieldsPost201Response> {
        const response = await this.versionUsersUserFieldsFieldPatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update pivot
     */
    async versionUsersUserFieldsFieldPivotPatchRaw(requestParameters: VersionUsersUserFieldsFieldPivotPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionCategoriesCategoryAwardsAwardPivotPatch200Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionUsersUserFieldsFieldPivotPatch().'
            );
        }

        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling versionUsersUserFieldsFieldPivotPatch().'
            );
        }

        if (requestParameters['field'] == null) {
            throw new runtime.RequiredError(
                'field',
                'Required parameter "field" was null or undefined when calling versionUsersUserFieldsFieldPivotPatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/users/{user}/fields/{field}/pivot`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user']))).replace(`{${"field"}}`, encodeURIComponent(String(requestParameters['field']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: VersionCategoriesCategoryAwardsAwardPivotPatchRequestToJSON(requestParameters['versionCategoriesCategoryAwardsAwardPivotPatchRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionCategoriesCategoryAwardsAwardPivotPatch200ResponseFromJSON(jsonValue));
    }

    /**
     * Update pivot
     */
    async versionUsersUserFieldsFieldPivotPatch(requestParameters: VersionUsersUserFieldsFieldPivotPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionCategoriesCategoryAwardsAwardPivotPatch200Response> {
        const response = await this.versionUsersUserFieldsFieldPivotPatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of fields
     */
    async versionUsersUserFieldsGetRaw(requestParameters: VersionUsersUserFieldsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionFormsFormFieldsGet200Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionUsersUserFieldsGet().'
            );
        }

        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling versionUsersUserFieldsGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/users/{user}/fields`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionFormsFormFieldsGet200ResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of fields
     */
    async versionUsersUserFieldsGet(requestParameters: VersionUsersUserFieldsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionFormsFormFieldsGet200Response> {
        const response = await this.versionUsersUserFieldsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create field
     */
    async versionUsersUserFieldsPostRaw(requestParameters: VersionUsersUserFieldsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionFormsFormFieldsPost201Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionUsersUserFieldsPost().'
            );
        }

        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling versionUsersUserFieldsPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/users/{user}/fields`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FieldToJSON(requestParameters['field']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionFormsFormFieldsPost201ResponseFromJSON(jsonValue));
    }

    /**
     * Create field
     */
    async versionUsersUserFieldsPost(requestParameters: VersionUsersUserFieldsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionFormsFormFieldsPost201Response> {
        const response = await this.versionUsersUserFieldsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sync fields
     */
    async versionUsersUserFieldsSyncPatchRaw(requestParameters: VersionUsersUserFieldsSyncPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionCategoriesCategoryAwardsSyncPatch200Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionUsersUserFieldsSyncPatch().'
            );
        }

        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling versionUsersUserFieldsSyncPatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/users/{user}/fields/sync`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: VersionCategoriesCategoryAwardsAttachPostRequestToJSON(requestParameters['versionCategoriesCategoryAwardsAttachPostRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionCategoriesCategoryAwardsSyncPatch200ResponseFromJSON(jsonValue));
    }

    /**
     * Sync fields
     */
    async versionUsersUserFieldsSyncPatch(requestParameters: VersionUsersUserFieldsSyncPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionCategoriesCategoryAwardsSyncPatch200Response> {
        const response = await this.versionUsersUserFieldsSyncPatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Toggle fields
     */
    async versionUsersUserFieldsTogglePatchRaw(requestParameters: VersionUsersUserFieldsTogglePatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionCategoriesCategoryAwardsTogglePatch200Response>> {
        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling versionUsersUserFieldsTogglePatch().'
            );
        }

        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling versionUsersUserFieldsTogglePatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKey", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{version}/users/{user}/fields/toggle`.replace(`{${"version"}}`, encodeURIComponent(String(requestParameters['version']))).replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: VersionCategoriesCategoryAwardsAttachPostRequestToJSON(requestParameters['versionCategoriesCategoryAwardsAttachPostRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionCategoriesCategoryAwardsTogglePatch200ResponseFromJSON(jsonValue));
    }

    /**
     * Toggle fields
     */
    async versionUsersUserFieldsTogglePatch(requestParameters: VersionUsersUserFieldsTogglePatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionCategoriesCategoryAwardsTogglePatch200Response> {
        const response = await this.versionUsersUserFieldsTogglePatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const VersionUsersUserFieldsAttachPostVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionUsersUserFieldsAttachPostVersionEnum = typeof VersionUsersUserFieldsAttachPostVersionEnum[keyof typeof VersionUsersUserFieldsAttachPostVersionEnum];
/**
 * @export
 */
export const VersionUsersUserFieldsBatchDeleteVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionUsersUserFieldsBatchDeleteVersionEnum = typeof VersionUsersUserFieldsBatchDeleteVersionEnum[keyof typeof VersionUsersUserFieldsBatchDeleteVersionEnum];
/**
 * @export
 */
export const VersionUsersUserFieldsBatchPatchVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionUsersUserFieldsBatchPatchVersionEnum = typeof VersionUsersUserFieldsBatchPatchVersionEnum[keyof typeof VersionUsersUserFieldsBatchPatchVersionEnum];
/**
 * @export
 */
export const VersionUsersUserFieldsBatchPostVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionUsersUserFieldsBatchPostVersionEnum = typeof VersionUsersUserFieldsBatchPostVersionEnum[keyof typeof VersionUsersUserFieldsBatchPostVersionEnum];
/**
 * @export
 */
export const VersionUsersUserFieldsDetachDeleteVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionUsersUserFieldsDetachDeleteVersionEnum = typeof VersionUsersUserFieldsDetachDeleteVersionEnum[keyof typeof VersionUsersUserFieldsDetachDeleteVersionEnum];
/**
 * @export
 */
export const VersionUsersUserFieldsFieldDeleteVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionUsersUserFieldsFieldDeleteVersionEnum = typeof VersionUsersUserFieldsFieldDeleteVersionEnum[keyof typeof VersionUsersUserFieldsFieldDeleteVersionEnum];
/**
 * @export
 */
export const VersionUsersUserFieldsFieldGetVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionUsersUserFieldsFieldGetVersionEnum = typeof VersionUsersUserFieldsFieldGetVersionEnum[keyof typeof VersionUsersUserFieldsFieldGetVersionEnum];
/**
 * @export
 */
export const VersionUsersUserFieldsFieldPatchVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionUsersUserFieldsFieldPatchVersionEnum = typeof VersionUsersUserFieldsFieldPatchVersionEnum[keyof typeof VersionUsersUserFieldsFieldPatchVersionEnum];
/**
 * @export
 */
export const VersionUsersUserFieldsFieldPivotPatchVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionUsersUserFieldsFieldPivotPatchVersionEnum = typeof VersionUsersUserFieldsFieldPivotPatchVersionEnum[keyof typeof VersionUsersUserFieldsFieldPivotPatchVersionEnum];
/**
 * @export
 */
export const VersionUsersUserFieldsGetVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionUsersUserFieldsGetVersionEnum = typeof VersionUsersUserFieldsGetVersionEnum[keyof typeof VersionUsersUserFieldsGetVersionEnum];
/**
 * @export
 */
export const VersionUsersUserFieldsPostVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionUsersUserFieldsPostVersionEnum = typeof VersionUsersUserFieldsPostVersionEnum[keyof typeof VersionUsersUserFieldsPostVersionEnum];
/**
 * @export
 */
export const VersionUsersUserFieldsSyncPatchVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionUsersUserFieldsSyncPatchVersionEnum = typeof VersionUsersUserFieldsSyncPatchVersionEnum[keyof typeof VersionUsersUserFieldsSyncPatchVersionEnum];
/**
 * @export
 */
export const VersionUsersUserFieldsTogglePatchVersionEnum = {
    V1: 'v1',
    V2: 'v2'
} as const;
export type VersionUsersUserFieldsTogglePatchVersionEnum = typeof VersionUsersUserFieldsTogglePatchVersionEnum[keyof typeof VersionUsersUserFieldsTogglePatchVersionEnum];
